//
// ASNParser
//
// Copyright 1997 Equivalence Pty. Ltd.
//

#include <ptlib.h>

#include "main.h"
#include "asn_grammar.h"

unsigned lineNumber;
PString  fileName;

unsigned fatals, warnings;

extern FILE * yyin;
extern int yydebug;

ModuleDefinition * Module;


ostream & operator<<(ostream & s, PInt64 i)
{
  return s << psprintf("%I64u", i);
}


static PString MakeIdentifierC(const PString & identifier)
{
  PString s = identifier;
  s.Replace("-", "_", TRUE);
  return s;
}


/////////////////////////////////////////
//
//  yyerror
//  required function for flex
//

void yyerror(char * str)
{
  extern char * yytext;
  PError << StdError(Fatal) << str << " near token \"" << yytext <<"\"\n";
}

ostream & operator<<(ostream & out, const StdError & e)
{
  out << fileName << '(' << lineNumber << ") : ";
  if (e.e == Fatal) {
    fatals++;
    out << "error";
  }
  else {
    warnings++;
    out << "warning";
  }
  return out << ": ";
}

/////////////////////////////////////////////////////////
//
//  Application
//

PDECLARE_CLASS(App, PProcess)
  public:
    void Main();
};

PCREATE_PROCESS(App);

void App::Main()
{
  PArgList & args = GetArguments();
  args.Parse("dvco:m:n");

  if (args.GetCount() < 1 || args.GetCount() > 1) {
    PError << "usage: asnparse [-d] [-v] [-c] [-o outfile] asnfile" << endl;
    return;
  }

  PTextFile prcFile;
  if (!prcFile.Open(args[0], PFile::ReadOnly)) {
    PError << GetName() << ": cannot open \"" 
         << prcFile.GetFilePath() << "\" :" << prcFile.GetErrorText() << endl;
    return;
  }

  if (args.HasOption('d'))
    yydebug = 1;

  fileName   = prcFile.GetFilePath();
  lineNumber = 1;
  fatals     = 0;
  warnings   = 0;

  yyin = _fdopen(prcFile.GetHandle(), "r");
  PAssertNULL(yyin);
  yyparse();

  if (Module != NULL) {
    if (args.HasOption('v'))
      PError << "Module " << *Module << endl;

    if (args.HasOption('c')) {
      PFilePath fn = args.GetOptionString('o', args[0]);
      fn.SetType(".h");
      PTextFile hdrFile(fn, PFile::WriteOnly);
      fn.SetType(".cxx");
      PTextFile cxxFile(fn, PFile::WriteOnly);
      if (hdrFile.IsOpen() && cxxFile.IsOpen()) {
        PString headerName = hdrFile.GetFilePath().GetFileName();
        PString sourceName = cxxFile.GetFilePath().GetFileName();
        Module->moduleName = args.GetOptionString('m', MakeIdentifierC(Module->moduleName));
        hdrFile << "//\n"
                   "// " << headerName << "\n"
                   "//\n"
                   "// Code automatically generated by asnparse.\n"
                   "//\n"
                   "\n"
                   "#ifndef __" << Module->moduleName.ToUpper() << "_H\n"
                   "#define __" << Module->moduleName.ToUpper() << "_H\n"
                   "\n"
                   "#ifdef __GNUC__\n"
                   "#pragma interface\n"
                   "#endif\n"
                   "\n"
                   "#include <asner.h>\n"
                   "\n";
        cxxFile << "//\n"
                   "// " << sourceName << "\n"
                   "//\n"
                   "// Code automatically generated by asnparse.\n"
                   "//\n"
                   "\n"
                   "#ifdef __GNUC__\n"
                   "#pragma implementation \"" << headerName << "\"\n"
                   "#endif\n"
                   "\n"
                   "#include <ptlib.h>\n"
                   "#include \"" << headerName << "\"\n"
                   "\n";
        if (args.HasOption('n'))
          hdrFile << "namespace " << Module->moduleName << " {\n"
                     "\n";
        else
          hdrFile << "struct " << Module->moduleName << " {\n"
                     "\n";
        cxxFile << "#define new PNEW\n"
                   "\n"
                   "\n";

        Module->GenerateCplusplus(hdrFile, cxxFile);

        hdrFile << "};\n"
                   "\n"
                   "#endif // __" << Module->moduleName.ToUpper() << "_H\n"
                   "\n"
                   "// End of " << headerName << '\n';
        cxxFile << "// End of " << sourceName << '\n';
      }
    }
  }
}


/////////////////////////////////////////
//
//  miscellaneous
//

class indent
{
  public:
    indent() { }
    friend ostream & operator<<(ostream & s, const indent &)
    { return s << setw(Module->GetIndentLevel()*3) << ' '; }
};


/////////////////////////////////////////
//
//  intermediate structures from parser
//

NamedNumber::NamedNumber(PString * nam)
  : name(*nam)
{
  delete nam;
  number = 0;
  autonumber = TRUE;
}


NamedNumber::NamedNumber(PString * nam, int num)
  : name(*nam)
{
  delete nam;
  number = num;
  autonumber = FALSE;
}


NamedNumber::NamedNumber(PString * nam, const PString & ref)
  : name(*nam), reference(ref)
{
  delete nam;
  number = 0;
  autonumber = FALSE;
}


void NamedNumber::PrintOn(ostream & strm) const
{
  strm << name << " (";
  if (reference.IsEmpty())
    strm << number;
  else
    strm << reference;
  strm << ')';
}


void NamedNumber::SetAutoNumber(const NamedNumber & prev)
{
  if (autonumber) {
    number = prev.number + 1;
    autonumber = FALSE;
  }
}


Tag::Tag(unsigned tagNum)
{
  type = Universal;
  number = tagNum;
  mode = Module->GetDefaultTagMode();
}


void Tag::PrintOn(ostream & strm) const
{
  if (type != Universal || type != IllegalUniversalTag) {
    strm << '[';
    if (type != ContextSpecific)
      strm << classNames[type] << ' ';
    strm << number << "] " << modeNames[mode] << ' ';
  }
}


const char * Tag::classNames[] = {
  "UNIVERSAL", "APPLICATION", "CONTEXTSPECIFIC", "PRIVATE"
};


const char * Tag::modeNames[] = {
  "IMPLICIT", "EXPLICIT", "AUTOMATIC"
};


ValueElementBase::ValueElementBase()
{
  exclusions = NULL;
}


BOOL ValueElementBase::GenerateConstructor(ostream &, ostream &)
{
  PError << StdError(Warning) << "unsupported constraint, ignored." << endl;
  return FALSE;
}


BOOL ValueElementBase::HasPrefix(Constraint::Prefix)
{
  return FALSE;
}


ConstrainAllValueElement::ConstrainAllValueElement(ValueElementBase * excl)
{
  SetExclusions(excl);
}


ListValueElement::ListValueElement(ValueElementList * list)
  : elements(*list)
{
  delete list;
}


void ListValueElement::PrintOn(ostream & strm) const
{
  elements.PrintOn(strm);
}


BOOL ListValueElement::GenerateConstructor(ostream & hdr, ostream & cxx)
{
  if (elements.GetSize() > 1)
    PError << StdError(Warning) << "unsupported INTERSECTION constraints, ignored." << endl;
  return elements[0].GenerateConstructor(hdr, cxx);
}


BOOL ListValueElement::HasPrefix(Constraint::Prefix pref)
{
  return elements[0].HasPrefix(pref);
}


SingleValueElement::SingleValueElement(ValueBase * val)
{
  value = val;
}


SingleValueElement::~SingleValueElement()
{
  delete value;
}


void SingleValueElement::PrintOn(ostream & strm) const
{
  strm << *value;
}


BOOL SingleValueElement::GenerateConstructor(ostream & hdr, ostream & cxx)
{
  if (value->IsDescendant(IntegerValue::Class())) {
    cxx << ", ";
    value->GenerateCplusplus(hdr, cxx);
    cxx << ", ";
    value->GenerateCplusplus(hdr, cxx);
  }
  else if (value->IsDescendant(CharacterStringValue::Class())) {
    cxx << ", ";
    value->GenerateCplusplus(hdr, cxx);
  }
  else {
    PError << StdError(Warning) << "Unsupported constraint type, ignoring." << endl;
    return FALSE;
  }
  return TRUE;
}


ValueRangeElement::ValueRangeElement(ValueBase * lowerBound, ValueBase * upperBound)
{
  lower = lowerBound;
  upper = upperBound;
}


ValueRangeElement::~ValueRangeElement()
{
  delete lower;
  delete upper;
}


void ValueRangeElement::PrintOn(ostream & strm) const
{
  strm << *lower << ".." << *upper;
}


BOOL ValueRangeElement::GenerateConstructor(ostream & hdr, ostream & cxx)
{
  cxx << ", ";
  lower->GenerateCplusplus(hdr, cxx);
  cxx << ", ";
  upper->GenerateCplusplus(hdr, cxx);
  return TRUE;
}


SubTypeValueElement::SubTypeValueElement(TypeBase * typ)
{
  type = typ;
}


SubTypeValueElement::~SubTypeValueElement()
{
  delete type;
}


ConstraintValueElement::ConstraintValueElement(Constraint * con)
{
  constraint = con;
}


ConstraintValueElement::~ConstraintValueElement()
{
  delete constraint;
}


void ConstraintValueElement::PrintOn(ostream & strm) const
{
  constraint->PrintOn(strm);
}


BOOL ConstraintValueElement::GenerateConstructor(ostream & hdr, ostream & cxx)
{
  return constraint->GenerateConstructor(hdr, cxx);
}


BOOL ConstraintValueElement::HasPrefix(Constraint::Prefix pref)
{
  return constraint->HasPrefix(pref);
}


Constraint::Constraint(ValueElementList * std, BOOL extend, ValueElementList * ext)
{
  if (std != NULL) {
    standard = *std;
    delete std;
  }
  extendable = extend;
  if (ext != NULL) {
    extensions = *ext;
    delete ext;
  }
  prefix = NoPrefix;
}


void Constraint::PrintOn(ostream & strm) const
{
  switch (prefix) {
    case SizePrefix :
      strm << "SIZE";
      break;
    case FromPrefix :
      strm << "FROM";
      break;
    case WithComponentPrefix :
      strm << "WITH COMPONENT";
      break;
  }
  strm << '(';
  for (PINDEX i = 0; i < standard.GetSize(); i++)
    strm << standard[i];
  if (extendable) {
    strm << indent();
    if (standard.GetSize() > 0)
      strm << ", ";
    strm << "..., ";
    for (PINDEX i = 0; i < extensions.GetSize(); i++)
      strm << extensions[i];
  }
  strm << ')';
}


BOOL Constraint::GenerateConstructor(ostream & hdr, ostream & cxx)
{
  if (standard.GetSize() > 1)
    PError << StdError(Warning) << "unsupported UNION constraints, ignored." << endl;
  if (extensions.GetSize() > 0)
    PError << StdError(Warning) << "unsupported extension constraints, ignored." << endl;
  if (standard[0].GenerateConstructor(hdr, cxx))
    cxx << (extendable ? ", PASN_ConstrainedObject::ExtendableConstraint"
                       : ", PASN_ConstrainedObject::FixedConstraint");
  return FALSE;
}


BOOL Constraint::HasPrefix(Prefix pref)
{
  if (prefix == pref)
    return TRUE;

  return standard[0].HasPrefix(pref);
}


TypeBase::TypeBase(unsigned tagNum)
  : tag(tagNum), defaultTag(tagNum)
{
  isOptional = FALSE;
  defaultValue = NULL;
  isGenerated = FALSE;
}


TypeBase::TypeBase(const PString & nam, const Tag & theTag, BOOL opt)
  : name(nam), tag(theTag), defaultTag(theTag)
{
  isOptional = opt;
  defaultValue = NULL;
  isGenerated = FALSE;
}


void TypeBase::PrintOn(ostream & strm) const
{
  PrintStart(strm);
  PrintFinish(strm);
}


void TypeBase::PrintStart(ostream & strm) const
{
  strm << indent();
  if (!name)
    strm << name << ": ";
  strm << tag << GetClass() << ' ';
  Module->SetIndentLevel(1);
}


void TypeBase::PrintFinish(ostream & strm) const
{
  Module->SetIndentLevel(-1);
  strm << ' ' << constraints;
  if (isOptional)
    strm << " OPTIONAL";
  if (defaultValue != NULL)
    strm << " DEFAULT " << *defaultValue;
  strm << '\n';
}


int TypeBase::GetIdentifierTokenContext() const
{
  return IDENTIFIER;
}


void TypeBase::SetName(PString * newName)
{
  name = *newName;
  delete newName;
}


PString TypeBase::GetIdentifier() const
{
  return MakeIdentifierC(name);
}


void TypeBase::SetTag(Tag::Type type, unsigned num, Tag::Mode mode)
{
  tag.type = type;
  tag.number = num;
  tag.mode = mode;
}


void TypeBase::FlattenUsedTypes(TypesList &)
{
}


TypeBase * TypeBase::FlattenThisType(const TypeBase &, TypesList &)
{
  return this;
}


BOOL TypeBase::IsChoice() const
{
  return FALSE;
}


void TypeBase::GenerateCplusplus(ostream & hdr, ostream & cxx)
{
  BeginGenerateCplusplus(hdr, cxx);

  // Output header file declaration of class
  hdr << ");\n";

  // Output cxx file implementation of class
  GenerateConstructorParams(hdr, cxx, TRUE);
  cxx << ")\n"
         "{\n";

  EndGenerateCplusplus(hdr, cxx);
}


void TypeBase::GenerateOperators(ostream &, ostream &)
{
}


PString TypeBase::GetTypeName() const
{
  return GetAncestorClass();
}


BOOL TypeBase::References(const TypeBase &) const
{
  return FALSE;
}


void TypeBase::ResolveReference(TypesList &)
{
}


static const char * UniversalTagClassNames[] = {
  "UniversalTagClass",
  "ApplicationTagClass",
  "ContextSpecificTagClass",
  "PrivateTagClass"
};

static const char * UniversalTagNames[] = {
  NULL,
  "UniversalBoolean",
  "UniversalInteger",
  "UniversalBitString",
  "UniversalOctetString",
  "UniversalNull",
  "UniversalObjectId",
  "UniversalObjectDescriptor",
  "UniversalExternalType",
  "UniversalReal",
  "UniversalEnumeration",
  "UniversalEmbeddedPDV",
  NULL,
  NULL,
  NULL,
  NULL,
  "UniversalSequence",
  "UniversalSet",
  "UniversalNumericString",
  "UniversalPrintableString",
  "UniversalTeletexString",
  "UniversalVideotexString",
  "UniversalIA5String",
  "UniversalUTCTime",
  "UniversalGeneralisedTime",
  "UniversalGraphicString",
  "UniversalVisibleString",
  "UniversalGeneralString",
  "UniversalUniversalString",
  NULL,
  "UniversalBMPString"
};


void TypeBase::BeginGenerateCplusplus(ostream & hdr, ostream & cxx)
{
  // Output header file declaration of class
  hdr << "//\n"
         "// " << GetName() << "\n"
         "//\n"
         "\n"
         "class " << GetIdentifier() << " : public " << GetTypeName() << "\n"
         "{\n"
         "    PCLASSINFO(" << GetIdentifier() << ", " << GetTypeName() << ")\n"
         "  public:\n"
         "    " << GetIdentifier() << "(unsigned tag = ";
  if (tag.type == Tag::Universal &&
      tag.number < PARRAYSIZE(UniversalTagNames) &&
      UniversalTagNames[tag.number] != NULL)
    hdr << UniversalTagNames[tag.number];
  else
    hdr << tag.number;
  hdr << ", TagClass tagClass = " << UniversalTagClassNames[tag.type];

  // Output cxx file implementation of class
  cxx << "//\n"
         "// " << GetName() << "\n"
         "//\n"
         "\n"
      << Module->moduleName << "::" << GetIdentifier() << "::" << GetIdentifier()
      << "(unsigned tag, TagClass tagClass)\n"
         "  : " << GetTypeName() << '(';
}


void TypeBase::EndGenerateCplusplus(ostream & hdr, ostream & cxx)
{
  GenerateOperators(hdr, cxx);
  // Output header file declaration of class
  hdr << "};\n"
         "\n"
         "\n";

  // Output cxx file implementation of class
  cxx << "}\n"
         "\n"
         "\n";

  isGenerated = TRUE;
}


void TypeBase::GenerateConstructorParams(ostream & hdr, ostream & cxx, BOOL passThru)
{
  if (passThru)
    cxx << "tag, tagClass";
  else if (HasNonStandardTag() || HasConstraints()) {
    if (tag.type == Tag::Universal &&
        tag.number < PARRAYSIZE(UniversalTagNames) &&
        UniversalTagNames[tag.number] != NULL)
      cxx << UniversalTagNames[tag.number];
    else
      cxx << tag.number;
    cxx << ", " << UniversalTagClassNames[tag.type];
  }

  if (HasConstraints()) {
    PINDEX i;
    // Reorder to make sure FROM clause is last
    for (i = 0; i < constraints.GetSize()-1; i++) {
      if (constraints[i].HasPrefix(Constraint::FromPrefix)) {
        constraints.DisallowDeleteObjects();
        constraints.Append(constraints.RemoveAt(i));
        constraints.AllowDeleteObjects();
        break;
      }
    }
    for (i = 0; i < constraints.GetSize(); i++)
      constraints[i].GenerateConstructor(hdr, cxx);
  }
}


DefinedType::DefinedType(PString * name)
  : TypeBase(Tag::IllegalUniversalTag),
    referenceName(*name)
{
  delete name;
  baseType = NULL;
  resolved = FALSE;
}


DefinedType::DefinedType(TypeBase * refType, const TypeBase & parent, TypesList & types)
  : TypeBase(refType->GetName(), refType->GetTag(), refType->IsOptional())
{
  types.Append(refType);

  if (!name)
    referenceName = parent.GetName() + '_' + name;
  else
    referenceName = parent.GetName() + "_subtype";
  refType->SetName(new PString(referenceName));

  defaultValue = NULL;
  baseType = refType;
  resolved = TRUE;
}


void DefinedType::PrintOn(ostream & strm) const
{
  PrintStart(strm);
  strm << referenceName << ' ';
  PrintFinish(strm);
}


void DefinedType::FlattenUsedTypes(TypesList & types)
{
  ResolveReference(types);
}


TypeBase * DefinedType::FlattenThisType(const TypeBase &, TypesList & types)
{
  ResolveReference(types);
  return this;
}


void DefinedType::ResolveReference(TypesList & types)
{
  if (resolved)
    return;
  resolved = TRUE;

  for (PINDEX i = 0; i < types.GetSize(); i++) {
    if (types[i].GetName() == referenceName) {
      baseType = &types[i];
      baseType->ResolveReference(types);
      if (!HasNonStandardTag())
        defaultTag = tag = baseType->GetTag();
      break;
    }
  }
}


BOOL DefinedType::IsChoice() const
{
  if (baseType != NULL)
    return baseType->IsChoice();
  return FALSE;
}


void DefinedType::GenerateOperators(ostream & hdr, ostream & cxx)
{
  if (baseType != NULL)
    baseType->GenerateOperators(hdr, cxx);
}


const char * DefinedType::GetAncestorClass() const
{
  if (baseType != NULL && HasConstraints())
    return baseType->GetAncestorClass();

  return NULL;
}


BOOL DefinedType::References(const TypeBase & type) const
{
  return type.GetName() == referenceName;
}


PString DefinedType::GetTypeName() const
{
  if (baseType != NULL && HasConstraints())
    return baseType->GetTypeName();

  return MakeIdentifierC(referenceName);
}


SelectionType::SelectionType(PString * name, TypeBase * base)
  : TypeBase(Tag::IllegalUniversalTag),
    selection(*name)
{
  delete name;
  baseType = PAssertNULL(base);
}


SelectionType::~SelectionType()
{
  delete baseType;
}


void SelectionType::PrintOn(ostream & strm) const
{
  PrintStart(strm);
  strm << selection << '<' << *baseType;
  PrintFinish(strm);
}


void SelectionType::FlattenUsedTypes(TypesList & types)
{
  baseType = baseType->FlattenThisType(*this, types);
}


TypeBase * SelectionType::FlattenThisType(const TypeBase & parent, TypesList & types)
{
  return new DefinedType(this, parent, types);
}


void SelectionType::GenerateCplusplus(ostream &, ostream &)
{
  PError << StdError(Fatal) << "Cannot generate code for Selection type" << endl;
  isGenerated = TRUE;
}


const char * SelectionType::GetAncestorClass() const
{
  return "";
}


BOOL SelectionType::References(const TypeBase & type) const
{
  return baseType->References(type);
}


BooleanType::BooleanType()
  : TypeBase(Tag::UniversalBoolean)
{
}


void BooleanType::GenerateOperators(ostream & hdr, ostream &)
{
  hdr << "    " << GetIdentifier() << " & operator=(BOOL v) { SetValue(v); return *this; }\n";
}


const char * BooleanType::GetAncestorClass() const
{
  return "PASN_Boolean";
}


IntegerType::IntegerType()
  : TypeBase(Tag::UniversalInteger)
{
}


IntegerType::IntegerType(NamedNumberList * lst)
  : TypeBase(Tag::UniversalInteger),
    allowedValues(*lst)
{
  delete lst;
}


void IntegerType::GenerateOperators(ostream & hdr, ostream &)
{
  hdr << "    " << GetIdentifier() << " & operator=(int v) { SetValue(v); return *this; }\n"
         "    " << GetIdentifier() << " & operator=(unsigned v) { SetValue(v); return *this; }\n";
}


const char * IntegerType::GetAncestorClass() const
{
  return "PASN_Integer";
}


EnumeratedType::EnumeratedType(NamedNumberList * enums, BOOL extend, NamedNumberList * ext)
  : TypeBase(Tag::UniversalEnumeration),
    enumerations(*enums)
{
  numEnums = enums->GetSize();
  delete enums;
  extendable = extend;
  if (ext != NULL) {
    ext->DisallowDeleteObjects();
    for (PINDEX i = 0; i < ext->GetSize(); i++)
      enumerations.Append(ext->GetAt(i));
    delete ext;
  }
}


void EnumeratedType::PrintOn(ostream & strm) const
{
  PrintStart(strm);
  strm << '\n';
  for (PINDEX i = 0; i < numEnums; i++)
    strm << indent() << enumerations[i] << '\n';
  if (extendable) {
    strm << "...\n";
    for (; i < enumerations.GetSize(); i++)
      strm << indent() << enumerations[i] << '\n';
  }
  PrintFinish(strm);
}


TypeBase * EnumeratedType::FlattenThisType(const TypeBase & parent, TypesList & types)
{
  return new DefinedType(this, parent, types);
}


void EnumeratedType::GenerateCplusplus(ostream & hdr, ostream & cxx)
{
  PINDEX i;

  BeginGenerateCplusplus(hdr, cxx);
  GenerateConstructorParams(hdr, cxx, TRUE);

  // Output header file declaration of class
  hdr << ");\n"
         "\n"
         "    enum {\n";

  int maxEnumValue = 0;
  int prevNum;
  for (i = 0; i < enumerations.GetSize(); i++) {
    if (i > 0)
      hdr << ",\n";
    hdr << "      e_" << MakeIdentifierC(enumerations[i].GetName());
    int num = enumerations[i].GetNumber();
    if (maxEnumValue < num)
      maxEnumValue = num;
    if ((i == 0) ? (num != 0) : (num != prevNum+1))
      hdr << " = " << num;
    prevNum = num;
  }

  hdr << "\n"
         "    };\n";

  // Output cxx file implementation of class
  cxx << ", " << maxEnumValue << ", " << (extendable ? "TRUE" : "FALSE") << "\n"
         "#ifndef PASN_NOPRINTON\n"
         "      , \"";

  for (i = 0; i < enumerations.GetSize(); i++) {
    int num = enumerations[i].GetNumber();
    if (i > 0)
      cxx << "        \"";
    cxx << enumerations[i].GetName();
    if ((i == 0) ? (num != 0) : (num != prevNum+1))
      cxx << '=' << num;
    cxx << " \"\n";
    prevNum = num;
  }

  cxx << "#endif\n"
         "    )\n"
         "{\n";

  EndGenerateCplusplus(hdr, cxx);
}


void EnumeratedType::GenerateOperators(ostream & hdr, ostream &)
{
  hdr << "    " << GetIdentifier() << " & operator=(unsigned v) { SetValue(v); return *this; }\n";
}


const char * EnumeratedType::GetAncestorClass() const
{
  return "PASN_Enumeration";
}


RealType::RealType()
  : TypeBase(Tag::UniversalReal)
{
}


const char * RealType::GetAncestorClass() const
{
  return "PASN_Real";
}


BitStringType::BitStringType()
  : TypeBase(Tag::UniversalBitString)
{
}


BitStringType::BitStringType(NamedNumberList * lst)
  : TypeBase(Tag::UniversalBitString),
    allowedBits(*lst)
{
  delete lst;
}

int BitStringType::GetIdentifierTokenContext() const
{
  return OID_IDENTIFIER;
}


const char * BitStringType::GetAncestorClass() const
{
  return "PASN_BitString";
}


OctetStringType::OctetStringType()
  : TypeBase(Tag::UniversalOctetString)
{
}


void OctetStringType::GenerateOperators(ostream & hdr, ostream &)
{
  hdr << "    " << GetIdentifier() << " & operator=(const char * v) { SetValue(v); return *this; }\n"
         "    " << GetIdentifier() << " & operator=(const PString & v) { SetValue(v); return *this; }\n"
         "    " << GetIdentifier() << " & operator=(const PBYTEArray & v) { SetValue(v); return *this; }\n";
}


const char * OctetStringType::GetAncestorClass() const
{
  return "PASN_OctetString";
}


NullType::NullType()
  : TypeBase(Tag::UniversalNull)
{
}


const char * NullType::GetAncestorClass() const
{
  return "PASN_Null";
}


SequenceType::SequenceType(TypesList * std,
                           BOOL extend,
                           TypesList * ext,
                           unsigned tagNum)
  : TypeBase(tagNum)
{
  if (std != NULL) {
    numFields = std->GetSize();
    fields = *std;
    delete std;
  }
  else
    numFields = 0;
  extendable = extend;
  if (ext != NULL) {
    ext->DisallowDeleteObjects();
    for (PINDEX i = 0; i < ext->GetSize(); i++)
      fields.Append(ext->GetAt(i));
    delete ext;
  }
}


void SequenceType::PrintOn(ostream & strm) const
{
  PrintStart(strm);
  strm << '\n';
  PINDEX i;
  for (i = 0; i < numFields; i++)
    strm << fields[i];
  if (extendable) {
    strm << indent() << "...\n";
    for (; i < fields.GetSize(); i++)
      strm << fields[i];
  }
  PrintFinish(strm);
}


void SequenceType::FlattenUsedTypes(TypesList & types)
{
  for (PINDEX i = 0; i < fields.GetSize(); i++)
    fields.SetAt(i, fields[i].FlattenThisType(*this, types));
}


TypeBase * SequenceType::FlattenThisType(const TypeBase & parent, TypesList & types)
{
  return new DefinedType(this, parent, types);
}


void SequenceType::GenerateCplusplus(ostream & hdr, ostream & cxx)
{
  PINDEX i;

  BeginGenerateCplusplus(hdr, cxx);
  GenerateConstructorParams(hdr, cxx, TRUE);

  // Output header file declaration of class
  hdr << ");\n"
         "    PINDEX GetDataLength() const;\n"
         "    BOOL Decode(PASN_Stream & strm);\n"
         "    void Encode(PASN_Stream & strm) const;\n"
         "#ifndef PASN_NOPRINTON\n"
         "    void PrintOn(ostream & strm) const;\n"
         "#endif\n"
         "\n";

  PINDEX baseOptions = 0;
  BOOL outputEnum = FALSE;
  for (i = 0; i < fields.GetSize(); i++) {
    if (i < numFields && fields[i].IsOptional())
      baseOptions++;
    if (i >= numFields || fields[i].IsOptional()) {
      if (outputEnum)
        hdr << ",\n";
      else {
        hdr << "    enum {\n";
        outputEnum = TRUE;
      }
      hdr << "      e_" << fields[i].GetIdentifier();
    }
  }

  if (outputEnum)
    hdr << "\n"
           "    };\n"
           "\n";

  for (i = 0; i < fields.GetSize(); i++)
    hdr << "    " << fields[i].GetTypeName() << " m_" << fields[i].GetIdentifier() << ";\n";

  // Output cxx file implementation of class
  cxx << ", " << baseOptions << ", "
      << (extendable ? "TRUE" : "FALSE") << ", "
      << fields.GetSize() - numFields
      << ')';

  for (i = 0; i < fields.GetSize(); i++) {
    if (fields[i].HasConstraints() || fields[i].HasNonStandardTag()) {
      cxx << ",\n"
             "    m_" << fields[i].GetIdentifier() << '(';
      fields[i].GenerateConstructorParams(hdr, cxx, FALSE);
      cxx << ')';
    }
  }

  cxx << "\n"
         "{\n"
         "}\n"
         "\n"
         "\n"
         "#ifndef PASN_NOPRINTON\n"
         "void " << Module->moduleName << "::" << GetIdentifier() << "::PrintOn(ostream & strm) const\n"
         "{\n"
         "  int indent = strm.precision() + 2;\n"
         "  strm << \"{\\n\";\n";

  for (i = 0; i < numFields; i++) {
    if (fields[i].IsOptional())
      cxx << "  if (HasOptionalField(e_" << fields[i].GetIdentifier() << "))\n"
             "  ";
    cxx << "  strm << setw(indent) << ' ' << \""
        << fields[i].GetIdentifier() << " = \" << setprecision(indent) << m_"
        << fields[i].GetIdentifier() << " << '\\n';\n";
  }

  cxx << "  strm << setw(indent-1) << '}';\n"
         "}\n"
         "#endif\n"
         "\n"
         "\n"
         "PINDEX " << Module->moduleName << "::" << GetIdentifier() << "::GetDataLength() const\n"
         "{\n"
         "  return ";

  outputEnum = FALSE;
  for (i = 0; i < numFields; i++) {
    if (outputEnum)
      cxx << " +\n"
             "         ";
    else
      outputEnum = TRUE;
    cxx << "m_" << fields[i].GetIdentifier() << ".GetObjectLength()";
  }
  if (!outputEnum)
    cxx << '0';

  cxx << ";\n"
         "}\n"
         "\n"
         "\n"
         "BOOL " << Module->moduleName << "::" << GetIdentifier() << "::Decode(PASN_Stream & strm)\n"
         "{\n"
         "  if (!PreambleDecode(strm))\n"
         "    return FALSE;\n\n";

  for (i = 0; i < numFields; i++) {
    cxx << "  if (";
    if (fields[i].IsOptional())
      cxx << "HasOptionalField(e_" << fields[i].GetIdentifier() << ") && ";
    cxx << "!m_" << fields[i].GetIdentifier() << ".Decode(strm))\n"
           "    return FALSE;\n";
  }

  for (; i < fields.GetSize(); i++)
    cxx << "  if (!KnownExtensionDecode(strm, e_"
        << fields[i].GetIdentifier()
        << ", m_" << fields[i].GetIdentifier() << "))\n"
           "    return FALSE;\n";

  cxx << "\n"
         "  return UnknownExtensionsDecode(strm);\n"
         "}\n"
         "\n"
         "\n"
         "void " << Module->moduleName << "::" << GetIdentifier() << "::Encode(PASN_Stream & strm) const\n"
         "{\n"
         "  PreambleEncode(strm);\n\n";

  for (i = 0; i < numFields; i++) {
    if (fields[i].IsOptional())
      cxx << "  if (HasOptionalField(e_" << fields[i].GetIdentifier() << "))\n"
             "  ";
    cxx << "  m_" << fields[i].GetIdentifier() << ".Encode(strm);\n";
  }

  for (; i < fields.GetSize(); i++)
    cxx << "  KnownExtensionEncode(strm, e_"
        << fields[i].GetIdentifier()
        << ", m_" << fields[i].GetIdentifier() << ");\n";

  cxx << "\n"
         "  UnknownExtensionsEncode(strm);\n";

  EndGenerateCplusplus(hdr, cxx);
}


const char * SequenceType::GetAncestorClass() const
{
  return "PASN_Sequence";
}


BOOL SequenceType::References(const TypeBase & type) const
{
  for (PINDEX i = 0; i < fields.GetSize(); i++)
    if (fields[i].References(type))
      return TRUE;
  return FALSE;
}


SequenceOfType::SequenceOfType(TypeBase * base, Constraint * constraint, unsigned tag)
  : TypeBase(tag)
{
  baseType = base;
  if (constraint != NULL)
    AddConstraint(constraint);
}


SequenceOfType::~SequenceOfType()
{
  delete baseType;
}


void SequenceOfType::PrintOn(ostream & strm) const
{
  PrintStart(strm);
  if (baseType == NULL)
    strm << "!!Null Type!!\n";
  else
    strm << *baseType << '\n';
  PrintFinish(strm);
}


void SequenceOfType::FlattenUsedTypes(TypesList & types)
{
  baseType = baseType->FlattenThisType(*this, types);
}


TypeBase * SequenceOfType::FlattenThisType(const TypeBase & parent, TypesList & types)
{
  return new DefinedType(this, parent, types);
}


void SequenceOfType::GenerateCplusplus(ostream & hdr, ostream & cxx)
{
  BeginGenerateCplusplus(hdr, cxx);

  // Output header file declaration of class
  hdr << ");\n"
         "    PASN_Object * CreateObject() const;\n"
         "    " << baseType->GetTypeName() << " & operator[](PINDEX i)\n"
         "      { return (" << baseType->GetTypeName() << " &)array[i]; }\n";

  // Output cxx file implementation of class
  GenerateConstructorParams(hdr, cxx, TRUE);
  cxx << ")\n"
         "{\n"
         "}\n"
         "\n"
         "\n"
         "PASN_Object * " << Module->moduleName << "::" << GetIdentifier() << "::CreateObject() const\n"
         "{\n"
         "  return new " << baseType->GetTypeName() << ";\n";

  EndGenerateCplusplus(hdr, cxx);
}


const char * SequenceOfType::GetAncestorClass() const
{
  return "PASN_Array";
}


SetType::SetType()
  : SequenceType(NULL, FALSE, NULL, Tag::UniversalSet)
{
}


SetType::SetType(SequenceType * seq)
  : SequenceType(*seq)
{
  tag.number = Tag::UniversalSet;
}


const char * SetType::GetAncestorClass() const
{
  return "PASN_Set";
}


SetOfType::SetOfType(TypeBase * base, Constraint * constraint)
  : SequenceOfType(base, constraint, Tag::UniversalSet)
{
}


ChoiceType::ChoiceType(TypesList * std,
                       BOOL extendable,
                       TypesList * extensions)
  : SequenceType(std, extendable, extensions, Tag::IllegalUniversalTag)
{
}


void ChoiceType::GenerateCplusplus(ostream & hdr, ostream & cxx)
{
  PINDEX i;

  BeginGenerateCplusplus(hdr, cxx);

  // Output header file declaration of class
  hdr << ");\n"
         "    BOOL CreateObject();\n"
         "\n";

  BOOL outputEnum = FALSE;
  unsigned prevNum;
  for (i = 0; i < fields.GetSize(); i++) {
    const Tag & fieldTag = fields[i].GetTag();
    if (fieldTag.mode == Tag::Automatic || !fields[i].IsChoice()) {
      if (outputEnum)
        hdr << ",\n";
      else {
        hdr << "    enum {\n";
        outputEnum = TRUE;
      }
      hdr << "      e_" << fields[i].GetIdentifier();
      if (fieldTag.mode != Tag::Automatic &&
            ((i == 0) ? (fieldTag.number != 0) : (fieldTag.number != prevNum+1)))
        hdr << " = " << fieldTag.number;
      prevNum = fieldTag.number;
    }
  }

  if (outputEnum)
    hdr << "\n"
           "    };\n";

  hdr << '\n';
  PStringSet typesOutput;
  typesOutput += GetIdentifier();
  for (i = 0; i < fields.GetSize(); i++) {
    PString type = fields[i].GetTypeName();
    if (!typesOutput.Contains(type)) {
      hdr << "  operator " << type << " &() const { return ("
          << type << " &)GetObject(); }\n";
      typesOutput += type;
    }
  }

  // Output cxx file implementation of class
  GenerateConstructorParams(hdr, cxx, TRUE);
  cxx << ", " << numFields << ", " << (extendable ? "TRUE" : "FALSE");

  outputEnum = FALSE;
  for (i = 0; i < fields.GetSize(); i++) {
    const Tag & fieldTag = fields[i].GetTag();
    if (fieldTag.mode == Tag::Automatic || !fields[i].IsChoice()) {
      if (outputEnum)
        cxx << "        \"";
      else {
        cxx << "\n"
               "#ifndef PASN_NOPRINTON\n"
               "      , \"";
        outputEnum = TRUE;
      }
      cxx << fields[i].GetIdentifier();
      if (fieldTag.mode != Tag::Automatic &&
              ((i == 0) ? (fieldTag.number != 0) : (fieldTag.number != prevNum+1)))
        cxx << '=' << fieldTag.number;
      cxx << " \"\n";
      prevNum = fieldTag.number;
    }
  }

  if (outputEnum)
    cxx << "#endif\n"
           "    ";

  cxx << ")\n"
         "{\n"
         "}\n"
         "\n"
         "\n"
         "BOOL " << Module->moduleName << "::" << GetIdentifier() << "::CreateObject()\n"
         "{\n";

  outputEnum = FALSE;
  for (i = 0; i < fields.GetSize(); i++) {
    if (fields[i].GetTag().mode == Tag::Automatic || !fields[i].IsChoice()) {
      if (!outputEnum) {
        cxx << "  switch (tag) {\n";
        outputEnum = TRUE;
      }
      cxx << "    case e_" << fields[i].GetIdentifier() << " :\n"
             "      choice = new " << fields[i].GetTypeName() << '(';
      fields[i].GenerateConstructorParams(hdr, cxx, FALSE);
      cxx << ");\n"
             "      return TRUE;\n";
    }
  }

  if (outputEnum)
    cxx << "  }\n"
           "\n";

  for (i = 0; i < fields.GetSize(); i++) {
    if (fields[i].GetTag().mode != Tag::Automatic && fields[i].IsChoice())
      cxx << "  choice = new " << fields[i].GetTypeName() << "(tag, tagClass);\n"
             "  if (((PASN_Choice*)choice)->CreateObject())\n"
             "    return TRUE;\n"
             "  delete choice;\n"
             "\n";
  }

  cxx << "  choice = NULL;\n"
         "  return FALSE;\n";

  EndGenerateCplusplus(hdr, cxx);
}


BOOL ChoiceType::IsChoice() const
{
  return TRUE;
}


const char * ChoiceType::GetAncestorClass() const
{
  return "PASN_Choice";
}


BOOL ChoiceType::References(const TypeBase &) const
{
  return FALSE;
}


EmbeddedPDVType::EmbeddedPDVType()
  : TypeBase(Tag::UniversalEmbeddedPDV)
{
}


const char * EmbeddedPDVType::GetAncestorClass() const
{
  return "PASN_EmbeddedPDV";
}


ExternalType::ExternalType()
  : TypeBase(Tag::UniversalExternalType)
{
}


const char * ExternalType::GetAncestorClass() const
{
  return "PASN_External";
}


BMPStringType::BMPStringType()
  : TypeBase(Tag::UniversalBMPString)
{
}


const char * BMPStringType::GetAncestorClass() const
{
  return "PASN_BMPString";
}


GeneralStringType::GeneralStringType()
  : TypeBase(Tag::UniversalGeneralString)
{
}


const char * GeneralStringType::GetAncestorClass() const
{
  return "PASN_GeneralString";
}


GraphicStringType::GraphicStringType()
  : TypeBase(Tag::UniversalGraphicString)
{
}


const char * GraphicStringType::GetAncestorClass() const
{
  return "PASN_GraphicString";
}


IA5StringType::IA5StringType()
  : TypeBase(Tag::UniversalIA5String)
{
}


const char * IA5StringType::GetAncestorClass() const
{
  return "PASN_IA5String";
}


ISO646StringType::ISO646StringType()
  : TypeBase(Tag::UniversalVisibleString)
{
}


const char * ISO646StringType::GetAncestorClass() const
{
  return "PASN_ISO646String";
}


NumericStringType::NumericStringType()
  : TypeBase(Tag::UniversalNumericString)
{
}


const char * NumericStringType::GetAncestorClass() const
{
  return "PASN_NumericString";
}


PrintableStringType::PrintableStringType()
  : TypeBase(Tag::UniversalPrintableString)
{
}


const char * PrintableStringType::GetAncestorClass() const
{
  return "PASN_PrintableString";
}


TeletexStringType::TeletexStringType()
  : TypeBase(Tag::UniversalTeletexString)
{
}


const char * TeletexStringType::GetAncestorClass() const
{
  return "PASN_TeletexString";
}


T61StringType::T61StringType()
  : TypeBase(Tag::UniversalTeletexString)
{
}


const char * T61StringType::GetAncestorClass() const
{
  return "PASN_T61String";
}


UniversalStringType::UniversalStringType()
  : TypeBase(Tag::UniversalUniversalString)
{
}


const char * UniversalStringType::GetAncestorClass() const
{
  return "PASN_UniversalString";
}


VideotexStringType::VideotexStringType()
  : TypeBase(Tag::UniversalVideotexString)
{
}


const char * VideotexStringType::GetAncestorClass() const
{
  return "PASN_VideotexString";
}


VisibleStringType::VisibleStringType()
  : TypeBase(Tag::UniversalVisibleString)
{
}


const char * VisibleStringType::GetAncestorClass() const
{
  return "PASN_VisibleString";
}


UnrestrictedCharacterStringType::UnrestrictedCharacterStringType()
  : TypeBase(Tag::UniversalUniversalString)
{
}


const char * UnrestrictedCharacterStringType::GetAncestorClass() const
{
  return "PASN_UnrestrictedString";
}


GeneralizedTimeType::GeneralizedTimeType()
  : TypeBase(Tag::UniversalGeneralisedTime)
{
}


const char * GeneralizedTimeType::GetAncestorClass() const
{
  return "PASN_GeneralizedTime";
}


UTCTimeType::UTCTimeType()
  : TypeBase(Tag::UniversalUTCTime)
{
}


const char * UTCTimeType::GetAncestorClass() const
{
  return "PASN_UTCTime";
}


ObjectDescriptorType::ObjectDescriptorType()
  : TypeBase(Tag::UniversalObjectDescriptor)
{
}


const char * ObjectDescriptorType::GetAncestorClass() const
{
  return "PASN_ObectDescriptor";
}


ObjectIdentifierType::ObjectIdentifierType()
  : TypeBase(Tag::UniversalObjectId)
{
}


int ObjectIdentifierType::GetIdentifierTokenContext() const
{
  return OID_IDENTIFIER;
}


const char * ObjectIdentifierType::GetAncestorClass() const
{
  return "PASN_ObjectId";
}


void ValueBase::SetValueName(PString * name)
{
  valueName = *name;
  delete name;
}


void ValueBase::PrintBase(ostream & strm) const
{
  if (!valueName)
    strm << '\n' << indent() << valueName << '=';
}


void ValueBase::GenerateCplusplus(ostream &, ostream &)
{
  PError << StdError(Warning) << "unsupported value type." << endl;
}


DefinedValue::DefinedValue(PString * name)
  : referenceName(*name)
{
  delete name;
  actualValue = NULL;
  resolved = FALSE;
}


void DefinedValue::PrintOn(ostream & strm) const
{
  PrintBase(strm);
  strm << referenceName;
}


void DefinedValue::GenerateCplusplus(ostream & hdr, ostream & cxx)
{
  if (!resolved) {
    const ValuesList & values = Module->GetValues();
    for (PINDEX i = 0; i < values.GetSize(); i++)
      if (values[i].GetName() == referenceName) {
        actualValue = &values[i];
        break;
      }
    resolved = TRUE;
  }

  if (actualValue != NULL)
    actualValue->GenerateCplusplus(hdr, cxx);
  else
    cxx << referenceName;
}


BooleanValue::BooleanValue(BOOL newVal)
{
  value = newVal;
}


void BooleanValue::PrintOn(ostream & strm) const
{
  PrintBase(strm);
  strm << (value ? "TRUE" : "FALSE");
}


void BooleanValue::GenerateCplusplus(ostream &, ostream & cxx)
{
  cxx << (value ? "TRUE" : "FALSE");
}


IntegerValue::IntegerValue(PInt64 newVal)
{
  value = newVal;
}


void IntegerValue::PrintOn(ostream & strm) const
{
  PrintBase(strm);
  
  strm << value;
}


void IntegerValue::GenerateCplusplus(ostream &, ostream & cxx)
{
  cxx << value;
}


RealValue::RealValue(double newVal)
{
  value = newVal;
}


BitStringValue::BitStringValue(PString * newVal)
{
  // value = *newVal;
  delete newVal;
}


BitStringValue::BitStringValue(PStringList * newVal)
{
  // value = *newVal;
  delete newVal;
}


CharacterStringValue::CharacterStringValue(PString * newVal)
{
  value = *newVal;
  delete newVal;
}


CharacterStringValue::CharacterStringValue(PStringList * newVal)
{
  for (PINDEX i = 0; i < newVal->GetSize(); i++)
    value += (*newVal)[i];
  delete newVal;
}


void CharacterStringValue::PrintOn(ostream & strm) const
{
  strm << value;
}


void CharacterStringValue::GenerateCplusplus(ostream &, ostream & cxx)
{
  cxx << value;
}


ObjectIdentifierValue::ObjectIdentifierValue(PString * newVal)
{
  value.Append(newVal);
}


ObjectIdentifierValue::ObjectIdentifierValue(PStringList * newVal)
{
  value = *newVal;
  delete newVal;
}


void ObjectIdentifierValue::PrintOn(ostream & strm) const
{
  PrintBase(strm);
  if (value.IsEmpty())
    strm << "empty object identifier";
  else {
    strm << value[0];
    for (PINDEX i = 1; i < value.GetSize(); i++)
      strm << '.' << value[i];
  }
  strm << '\n';
}


void MinValue::PrintOn(ostream & strm) const
{
  strm << "MIN";
}


void MinValue::GenerateCplusplus(ostream &, ostream & cxx)
{
  cxx << "INT_MIN";
}


void MaxValue::PrintOn(ostream & strm) const
{
  strm << "MAX";
}


void MaxValue::GenerateCplusplus(ostream &, ostream & cxx)
{
  cxx << "INT_MAX";
}


MibBase::MibBase(PString * nam,
                 PString * descr,
                 PString * refer,
                 ValueBase * val)
  : name(*nam)
{
  delete nam;
  if (descr != NULL) {
    description = *descr;
    delete descr;
  }
  if (refer != NULL) {
    reference = *refer;
    delete refer;
  }
  value = val;
}


MibBase::~MibBase()
{
  delete value;
}


MibObject::MibObject(PString * nam,
                     TypeBase * typ,
                     Access acc,
                     Status stat,
                     PString * descr,
                     PString * refer,
                     PStringList * idx,
                     ValueBase * defVal,
                     ValueBase * setVal)
  : MibBase(nam, descr, refer, setVal)
{
  type = typ;
  access = acc;
  status = stat;
  if (idx != NULL) {
    index = *idx;
    delete idx;
  }
  defaultValue = defVal;
}


MibObject::~MibObject()
{
  delete type;
  delete defaultValue;
}


void MibObject::PrintOn(ostream & strm) const
{
  strm << "  Object: " << name << "\n  " << *type
       << "    " << description << "\n"
          "    " << *value << '\n';
}


MibTrap::MibTrap(PString * nam, ValueBase * ent, ValuesList * var,
                 PString * descr, PString * refer, ValueBase * val)
  : MibBase(nam, descr, refer, val)
{
  enterprise = ent;
  if (var != NULL) {
    variables = *var;
    delete var;
  }
}


MibTrap::~MibTrap()
{
  delete enterprise;
}


void MibTrap::PrintOn(ostream & strm) const
{
  strm << "  Trap: " << name << "\n  " << *enterprise
       << "    " << description << "\n"
          "    " << *value << '\n';
}


ImportModule::ImportModule(PString * name, PStringList * syms)
{
  moduleName = *name;
  delete name;
  symbols = *syms;
  delete syms;
}


void ImportModule::PrintOn(ostream & strm) const
{
  strm << "  " << moduleName << ": ";
  for (PINDEX i = 0; i < symbols.GetSize(); i++)
    strm << symbols[i] << ' ';
  strm << '\n';
}


ModuleDefinition::ModuleDefinition(PString * name, PStringList * id, Tag::Mode defTagMode)
  : moduleName(*name),
    definitiveId(*id)
{
  delete name;
  delete id;
  defaultTagMode = defTagMode;
  exportAll = FALSE;
  indentLevel = 1;
}


void ModuleDefinition::SetExportAll()
{
  exportAll = TRUE;
}


void ModuleDefinition::SetExports(PStringList * syms)
{
  exports = *syms;
  delete syms;
}


void ModuleDefinition::PrintOn(ostream & strm) const
{
  strm << moduleName << "\n"
          "Default Tags: " << Tag::modeNames[defaultTagMode] << "\n"
          "Exports:";
  if (exportAll)
    strm << " ALL";
  else {
    strm << "\n  ";
    for (PINDEX i = 0; i < exports.GetSize(); i++)
      strm << exports[i] << ' ';
    strm << '\n';
  }
  strm << "Imports:\n" << imports << "\n"
          "Types:\n" << types << "\n"
          "Values:\n" << values << "\n"
          "MIBs:\n" << mibs << endl;
}


void ModuleDefinition::GenerateCplusplus(ostream & hdr, ostream & cxx)
{
  PINDEX i;
  // Flatten types by generating defined types
  for (i = 0; i < types.GetSize(); i++)
    types[i].FlattenUsedTypes(types);

  // Reorder types
  types.DisallowDeleteObjects();
  PINDEX loopDetect = 0;
  PINDEX bubble = 0;
  while (bubble < types.GetSize()) {
    const TypeBase & bubbleType = types[bubble];
    for (i = bubble; i < types.GetSize(); i++) {
      if (bubbleType.References(types[i])) {
        break;
      }
    }
    if (i < types.GetSize()) {
      types.Append(types.RemoveAt(bubble));
      if (loopDetect > types.GetSize()) {
        PError << StdError(Fatal)
               << "Recursive type definition: " << bubbleType.GetName() << endl;
        break;
      }
      loopDetect++;
    }
    else {
      loopDetect = bubble;
      bubble++;
    }
  }
  types.AllowDeleteObjects();

  for (i = 0; i < types.GetSize(); i++)
    hdr << "class " << types[i].GetIdentifier() << ";\n";
  hdr << "\n\n";

  // Generate the code
  for (i = 0; i < types.GetSize(); i++)
    types[i].GenerateCplusplus(hdr, cxx);
}


//////////////////////////////////////////////////////////////////////////////
